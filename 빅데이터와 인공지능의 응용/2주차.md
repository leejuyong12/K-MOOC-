# 2주차



## 인간 행동 탐지 및 응용



### 2-1. 인간 행동 탐지 소개

- AI기반의 응용들의 핵심 - 사용자의 행동을 이해하는 것

  - ex) 피지컬 액티비티, 이 사람이 어디 있는가?, 무슨 대화를 하는가?

- 더욱 더 구체적인 수준에서 이해해보자

  - 외적인 상태
    - GPS를 통해 실내의 위치도 알아내자, 평소 습관, 행동, 악기 연주 등등

  - 내적인 상태
    - 심리, 스트레스 등등

- 어떻게 탐지할 것인가??

  - 피지컬 활동 -> 신체의 움직임
    - 만보계, 스마트폰 등 - 걸음걸이 - 수평방향, 수직방향 - 가속도 체크
    - 스마트폰에 내장된 센서
      - 가속도계
        - 직진 방향의 선형가속을 측정
      - Gyroscope(자이로스콥)
        - 회전 움직임을 측정하게 되는 움직임을 다른 방식으로 측정하게 되는 센서
      - Compass(컴파스)
        - 스마트폰이 향하는 방향을 측정할 수 있게 됨으로써 움직임을 탐지하는데 있어서 방향정보를 추가할 수 있는 기회를 제공

### 2-2 관성센서 이해하기 : 만보계 예제

- 가속도계
  - 삼축 방향의 가속도를 센싱

- 이상적인 시그널과 현실적인 시그널의 차이
  - 이상적인 시그널
    - 한 축 방향만 존재
    - 굉장히 예쁜 주기적 패턴
  - 현실적인 시그널
    - 세가지 서로 다른 축 존재
    - 굉장히 노이즈하고 범피한 패턴

- 현실적인 시그널의 노이즈를 없애는 과정을 거치면 이상적인 시그널에 가까워지지 않을까?

  - Step1 - Convert to 1-axis magnitude(remove effect of orientation)

    - 한 축 방향으로 시그널을 바꾸는 과정

    - 이상적인 신호에 가까운 신호가 나와서 그것을 가지고 피크 수를 세고 스텝을 세보자하는게 핵심 아이디어

    - 한 축 방향으로 시그널을 어떻게 바꿀까?

      - 가장 쉽게는 Y축 방향의 시그널을 선택하자
      - why? 그 방향의 가속이 제일 크게 나타나기 때문이다.
      - But, 사람이 전화기를 수직 방향으로만 가지고 있다라는 보장이 없다.
      - 그래서 한 축 방향의 데이터를 선택적으로 사용하는 것은 위험하다.

    - 세 축 방향의 가속을 모두 합쳐서 한쪽 방향의 가장 큰 가속을 인식해내는 방식으로 한 축 방향으로 만들 수 있다.

      - 
        $$
        \sqrt{x^2 + y^2 + z^2}
        $$

      - 좀 더 기술적인 방법을 쓰자면 X Y Z 방향의 가속을 루트민스퀘어를 활용해가지고 한 축 방향의 가속으로 합치게 된다.

      - 이렇게 합치게 되면 조금 더 안정적인 시그널을 볼 수 있다.

      - But, 이렇게 해도 몇가지 문제가 있다.

      - 여전히 스텝당 한 번의 피크이 나타나는 패턴이 아니다.(한 스텝당 여러번 피크)

      - 걷지 않는 순간에도 피크가 나타날 수 있다.

      - 이는 여러가지 노이즈 때문에 나타나는 것이다.

      - 전화기가 다리에 딱 붙어있는게 아니라 조금씩 조금씩 흔들리게 되고 또 다른 여러가지 상황들이 있기 때문이다.

  - Step2 - Filter signals to remove noises and hightlight walking patterns

    - 센싱 데이터를 전처리 과정을 통해가지고 노이즈를 없애는 것은 어떤 종류의 머신러닝 기술을 활용하기 전에 항상 해야되는 일들이다.

    - 노이즈를 제거하는 기술(Time Domain Smoothing)

      - Moving Average Smoothing

        - 선서 데이터 한 포인트 씩 보면 너무 민감한 데이터들이다.
        - 그래서 각각의 데이터를 쓰는 게 아니라 주변의 여러 데이터를 묶어서 평균값을 데이터로 활용하자는 것이 핵심
        - S1 = (X1 + X2 + X3)/3 .....
        - 이렇게 하면 센서의 튀는 부분이나 민감하게 잘못 생성된 그런 값들이 없어지지 않을까 하는 게 핵심
        - 조심해야할 부분은 윈도우 사이즈를 정하는 것이다.
        - 너무 짧게 정했다면 에버리징 효과가 크게 나타나지 않을 것이다.
        - 크게 정하면 필터링 된 데이터가 굉장히 깨끗하게 나올 것이다.
        - 하지만 너무 큰 윈도우를 적용하게 된다면 시그널 안에 있는 정보가 다 뭉개져서 없어지게 된다.(각각의 데이터를 반영하기 힘들어진다)
        - 그래서 윈도우 사이즈를 탐지하고자 하는 정보의 양과 얼마만큼 많이 스무딩하고자 하는가 이것을 동시에 고려해가지고 잘 정해야 한다.

      - Exponential Smoothing

        - 반영하고자 하는 값의 가중치를 설정하여 반영한다.

          ![캡처](md-images/%EC%BA%A1%EC%B2%98.PNG)

        - 알파가 0.7이라고 했을때 현재값의 70%의 가중치를 주는 것이다.

        - 그러면 과거의 값에 30%의 가중치를 주는 것이므로 과거의 값에 대한 효과는 기하급수적으로 떨어지는 효과가 나타나게 된다.

        - 이 방법의 문제는 원래의 시그널에 비해서 피크가 굉장히 낮게 나오게 된다.

        - 그리고 피크가 나오는 것에 있어서 지연현상이 발생한다. 원래 데이터에 비해 피크가 뒤늦게 나타나는 지연형상이 나타나게 된다.

      - Median Filtering

        - ![캡처](md-images/%EC%BA%A1%EC%B2%98-1631775121898.PNG)
        - 윈도우를 적용해가지고 요약값을 쓰는 아이디어는 이전과 동일하다
        - 하지만 이 방법은 에버리지를 쓰는 것도 아니고 웨이트를 익스포넨셜하게 다르게 주는 것도 아니고 여기서는 이 윈도우에 있는 값들의 미디언 값을 뽑아가지고 그 값을 활용하게 된다.
        - 이 값을 활용하게 되면 Exponential Smoothing에서 봤던 문제들은 해결이 된다.
        - 피크도 원시그널과 굉장히 비슷하게 나오게 되고 지연현상도 나타나지 않는 것을 볼 수 있다.

    - Time Domain Smoothing을 적용하기 어려운 경우 Frequency Domain Filtering을 생각해볼 수 있다.

      - 푸리에 프리퀀시 트랜스폼(FFT)
        - 모든 종류의 시그널은 사인웨이브의 웨이트 Sum으로 되어있다.(이미지는 검색해보자)
      - 엑셀로미터 시그널이 굉장히 복잡하게 나타나지만 그것은 예쁜 사인 웨이브들 여러가지 서로 다른 주기와 진폭을 갖는 사인 웨이브들의 Sum으로 표현 될 수 있다라는 것이다.
      - 타임도메인의 시그널을 프리퀀시 도메인의 시그널로 변경한 다음에
      - 굉장히 Dominant 한 프리퀀시를 가지는 그런 시그널만을 뽑아내가지고 그 정보만 활용하고 나머지 프리퀀시에 있는 정보들은 다 빼버리는 것이다.
      - 그리고 나서 이것을 다시 타임 도메인으로 갖고 오면 굉장히 보고자 하는 사인 웨이브들 컴포넌트만 남아가지고 예쁜 시그널을 볼 수 있다.
      - Frequency Domain Filters
      - ![캡처](md-images/%EC%BA%A1%EC%B2%98-1631775865768.PNG)
      - low-pass filter - 낮은 프리퀀시만 필터링 시킨다.
      - hight-pass filter - 높은 프리퀀시만 필터링 시킨다.
      - bandpass filter - 중간 어떤 프리퀀시부터 어떤 프리퀀시까지 보고싶다라고 했을 때 그것을 필터링 해준다.
      - notch filter - 이 신호에서 어떤 프리퀀시는 빼고 싶다 하면 그 신호만 필터링 시킨다.

  - Step3 - Detect and count steps(peak detection)

    ​	![캡처](md-images/%EC%BA%A1%EC%B2%98-1631776287968.PNG)

    - 피크를 탐지하는 방법 - 미분값 활용
      - 미분값이 + 에서 -로 바뀌는 순간, 그 순간이 피크이다.
    - 피크가 나왔다고 해서 다 걸음인 것이 아니기 때문에 피크가 나오는 점을 확인하고 그 점의  Amplitude(진폭)을 확인해서 그게 어떤 이상이 되면 피크다 라고 확인할 수 있다.

### 2-3 활동 인식 기술

- 복잡한 활동들에 대해서 인식하는 기술
  - Activity Recognition - 사용자의 신체활동을 알아내는 기술
- 분류 문제
  - 2-2에서 알아본 기술은 탐지 문제 였다.
  - 분류문제는 데이터가 왔을 때 이 데이터가 과연 어떤 액티비티 타입에 해당하는 거냐 이걸 알고 싶을 때!
- Y axis 값의 표준편차가 작으면 standing, sitting 중에 하나 일 것이고, 크면 walking과 jogging중에 하나일 것이다.
- 1 - Labeld Data Collection
- 2 - Feature Extraction(Generation)
- 3 - Choose and Train a Classifier

- 기계학습 기술
  - 기계학습 기술은 시그널을 통해서 특징값들을 뽑고 이런 특징값들을 활용해가지고 자동으로 알고리즘을 만들어준다.
  - 이렇게 만들어진 알고리즘을 통해가지고 사람이 일일이 데이터를 지정해줄 필요 없이 학습된 데이터를 바탕으로 새로운 Acceleration signal이 왔을 때 이게 어떤 것에 해당되는지 알려주게 된다.
  - 충분한 양의 데이터를 필요로 한다.
    - 데이터를 모으는 데 가장 어려운 점은 레이블링을 해야 한다는 것이다.
    - 비지도 학습 방식도 있지만 이런 분류문제에 있어서는 흔히 지도학습 방식을 많이 쓰게 되는데 지도학습은 그 모델을 학습시킬 때 이 데이터가 어떤 곳의 Truth에 해당한다는 것을 알려줘야 한다.
    - 바로 그때그때 데이터를 수집할 수 있도록 데이터 수집기가 나오고 있다.
  - 데이터로부터 유의미한 특징값들을 뽑아내야 한다.
    - 유의미한 특징값을 뽑아내는 과정은 머신러닝 알고리즘이 어느 정도 자동으로 해주지만 그 프로그래머의 수동적인 개입이 여전히 중요한 과정이다.
    - 예를 들면 표준편차가 중요하다, 평균값이 중요하다 등등 어느 정도의 기준들을 가지고 이러한 특징(피쳐)들을 모델에서 활용해야 한다 라는 것을 지정해줘야 한다.
    - 특징(피쳐, feature)에는 두가지 종류가 있다. - 타임도메인 feature, 프리퀀시도메인 feature
      - 타임도메인 피쳐는 그냥 Temporal하게 윈도우를 적용해서 그 안에 있는 요약값들을 뽑아내는 것이다
      - 프리퀀시 도메인 피쳐는 타임도메인 피쳐를 FFT를 통해서 프리퀀시 도메인으로 바꾸고 거기서 나오는 정보들이 프리퀀시 도메인 피쳐가 된다.
    - 활용할 수 있는 모든 피쳐를 다 뽑아가지고 학습 알고리즘에 넣으면 좋은 피쳐를 뽑아내주지 않겠느냐?? 하는 생각이 있을 수 있는데 이건 어느정도는 맞는 얘기이다.
    - 하지만 너무 많은 피쳐를 넣게 되면 학습 과정에서 이 학습기가 완벽한 것들이 아니기 때문에 혼돈을 가져오게 된다.
    - 그래서 어느 정도는 개발자가 피쳐의 Superset을 정의해가지고 학습기에 좋은 피쳐들 위주로 넘겨주는 그런 과정이 필요하다.
    - 그 다음은 모델을 만들어서 분류하는 것은 그렇게 어려운 일은 아니다.
    - 개발자 입장에서는 트레이닝 데이터와 레이블을 주고 그 다음에 어떠한 피쳐들을 활용하고 싶다라는 것을 그 피쳐의 Superset 모델 학습기에다 넣게되면 자동으로 이 레이블들에 있는 액티비티들을 탐지할 수 있는 모델이 생성된다.
    - 그리고 새로운 데이터가 왔을때 이 데이터를 이 모델에 적용을 하면 이 데이터가 어떤 것에 해당되는지 알 수 있게 된다.
  - 디시전 트리(Decision Tree Classifier)
    - 이전의 휴리스틱과 조금 비슷하지만 가장 큰 차이는 어떤 피쳐를 쓰고 그 다음에 어떤 피쳐를 쓰고 이런 것들을 자동으로 결정한다는 것이다.
    - 데이터를 기반으로 학습이 되어 나온다.
    - 중요한 피쳐부터 덜 중요한 피쳐까지 이렇게 액티비티를 구별하는 과정을 쭉 거치게 된다.

- 여러 센서 데이터 사용 / 딥러닝 사용
